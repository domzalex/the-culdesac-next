'use client'
import React, { MouseEventHandler, TouchEventHandler } from 'react'
import { useState, useEffect, useRef } from "react"
import { useSession } from 'next-auth/react'

interface PlayerStats {
    lives: number,
    money: number,
}

interface Effect {
    type: string,
    amount: number
}

interface Tower {
    name: string,
    cost: number,
    range: number,
    damage: number,
    attackSpeed: number,
    lastAttackTime: number,
    effect?: Effect,
    radius: number,
    pos: {
        x: number,
        y: number
    }
}

interface Enemy {
    idx: number,
    hp: number,
    spd: number,
    money: number,
    radius: number,
    pos: {
        x: number,
        y: number
    },
    color: string
}

type Projectile = {
    pos: { x: number, y: number },
    targetPos: { x: number, y: number },
    speed: number,
    damage: number,
    collided: boolean
}

interface Map {
    collisions: number[],
    pathPoints: {x: number, y: number}[],
    name: string
}


const map1 = {
    collisions: [
        1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,1,
        1,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,
        1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,
        1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,
        0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,
        1,1,0,1,0,0,0,0,0,0,0,0,0,0,1,1,
        1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,1,
        0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,
        1,0,0,1,1,1,1,0,0,1,1,1,1,1,1,1,
        1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
        1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    ],
    pathPoints: [
        {x: 768, y: -64},
        {x: 768, y: 192},
        {x: 192, y: 192},
        {x: 192, y: 512},
        {x: 384, y: 512},
        {x: 384, y: 384},
        {x: 576, y: 384},
        {x: 576, y: 512},
        {x: 1088, y: 512},
    ],
    name: 'map1'
}

const map2 = {
    collisions: [
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,0,0,0,1,0,0,0,0,1,1,1,
        1,1,1,1,0,0,0,1,0,0,0,0,0,1,1,1,
        0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,
        1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,
        0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
        0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
        0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
        0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,
        1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,
    ],
    pathPoints: [
        { x: -64, y: 576 },
        { x: 704, y: 576 },
        { x: 832, y: 448 },
        { x: 832, y: 0 },
        { x: 576, y: 0 },
        { x: 320, y: 256 },
        { x: -64, y: 256 },
    ],
    name: 'map2'
}

const map3 = {
    collisions: [
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,
        1,1,0,0,1,1,1,1,1,1,1,1,0,0,1,1,
        1,1,0,1,0,0,0,0,0,0,0,0,1,0,1,1,
        1,1,0,1,0,0,0,0,0,0,0,0,1,0,1,1,
        1,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,
        1,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,
        1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,1,
        1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,
        1,1,1,1,0,1,0,1,1,0,1,0,1,1,1,1,
        1,1,1,1,0,1,0,1,1,0,1,0,1,1,1,1,
    ],
    pathPoints: [
        { x: 320, y: 768 },
        { x: 320, y: 576 },
        { x: 192, y: 448 },
        { x: 192, y: 256 },
        { x: 256, y: 192 },
        { x: 704, y: 192 },
        { x: 768, y: 256 },
        { x: 768, y: 448 },
        { x: 640, y: 576 },
        { x: 640, y: 768 },
    ],
    name: 'map3'
}

const enemyTypes = [
    {
        hp: 5,
        spd: 1,
        money: 5,
        color: 'rgb(192,38,13)'
    },
    {
        hp: 10,
        spd: 1.5,
        money: 10,
        color: 'rgb(45,106,170)'
    },
    {
        hp: 15,
        spd: 2,
        money: 15,
        color: 'rgb(80,152,34)'
    },
]

// waves generated by GPT for testing. 
// const waves = [
//     // Level 1: Weak enemies, simple mix
//     [
//         ...Array(10).fill({ hp: 1, spd: 1, money: 5 }),   // Basic weak enemies
//         ...Array(5).fill({ hp: 1, spd: 1, money: 5 }), // Slightly faster weak enemies
//     ],

//     // Level 2: Slight increase in speed and health
//     [
//         ...Array(12).fill({ hp: 1, spd: 1, money: 5 }),  // Faster weak enemies
//         ...Array(6).fill({ hp: 1, spd: 1, money: 5 }),     // Slightly tougher
//     ],

//     // Level 3: More tough enemies, slight increase in speed
//     [
//         ...Array(10).fill({ hp: 1, spd: 1, money: 5 }),    // Tougher basic enemies
//         ...Array(5).fill({ hp: 5, spd: 1.5, money: 8 }),   // Fast weak enemies
//     ],

//     // Level 4: Introducing a bit more challenge
//     [
//         ...Array(10).fill({ hp: 1, spd: 1, money: 5 }),   // Slightly slower but stronger
//         ...Array(10).fill({ hp: 5, spd: 1.5, money: 8 }),  // Mix of medium-speed
//     ],

//     // Level 5: Introduction of a small tanky enemy
//     [
//         ...Array(10).fill({ hp: 1, spd: 1, money: 5 }),  // Slow but tanky
//         ...Array(3).fill({ hp: 15, spd: 0.5, money: 10 }),  // Medium enemies
//         ...Array(7).fill({ hp: 1, spd: 1, money: 5 }),     // Very fast weak enemies
//     ],

//     // Continue increasing variation in enemies as we progress
//     // Level 6-10: More variations of speed, health, and enemy types
//     ...Array(5).fill(3).map((_, idx) => [
//         ...Array(8 + idx).fill({ hp: 3 + idx, spd: 1 + idx * 0.1, money: 4 + idx }), // Increasing health and speed
//         ...Array(5).fill({ hp: 1, spd: 2, money: 2 }),     // Keeping fast weak enemies
//         ...Array(4).fill({ hp: 5, spd: 0.8, money: 6 }),   // Slow tanky enemies
//     ]),

//     // Level 11-20: Mixes of medium and tougher enemies
//     ...Array(10).fill(3).map((_, idx) => [
//         ...Array(10 + idx).fill({ hp: 5 + idx, spd: 1.25 + idx * 0.05, money: 5 + idx }), // Steady progression
//         ...Array(6).fill({ hp: 2 + idx, spd: 2, money: 3 + idx }),  // Fast weak-medium enemies
//         ...Array(4).fill({ hp: 10 + idx, spd: 0.9, money: 8 + idx }), // Introduce more tanky ones
//     ]),

//     // Level 21-30: Higher health, with some fast ones
//     ...Array(10).fill(3).map((_, idx) => [
//         ...Array(15 + idx).fill({ hp: 10 + idx * 2, spd: 1 + idx * 0.05, money: 6 + idx * 2 }), // Health scaling more
//         ...Array(8).fill({ hp: 5 + idx, spd: 2.5, money: 4 + idx }),  // Fast medium enemies
//         ...Array(6).fill({ hp: 15 + idx * 2, spd: 0.75, money: 10 + idx * 2 }), // Tankier slow enemies
//     ]),

//     // Level 31-40: Stronger, more dangerous combinations
//     ...Array(10).fill(3).map((_, idx) => [
//         ...Array(20 + idx).fill({ hp: 20 + idx * 3, spd: 1.5 + idx * 0.05, money: 10 + idx * 2 }), // Larger and stronger
//         ...Array(10).fill({ hp: 8 + idx, spd: 3, money: 6 + idx * 2 }),  // Fast but tough enemies
//         ...Array(6).fill({ hp: 30 + idx * 3, spd: 0.5, money: 12 + idx * 3 }), // Super tanky
//     ]),

//     // Level 41-50: Final waves with extreme difficulty
//     ...Array(10).fill(3).map((_, idx) => [
//         ...Array(25 + idx).fill({ hp: 40 + idx * 5, spd: 2 + idx * 0.1, money: 15 + idx * 3 }), // Very tough and fast
//         ...Array(15).fill({ hp: 15 + idx, spd: 3.5, money: 8 + idx * 2 }),  // Extremely fast
//         ...Array(8).fill({ hp: 50 + idx * 5, spd: 0.5, money: 20 + idx * 4 }), // Final tanky enemies
//     ])
// ]

const waves = [
    [
        ...Array(20).fill(enemyTypes[0])
    ],

    // Level 2: Slight increase in speed and health
    [
        ...Array(10).fill(enemyTypes[0]),
        ...Array(10).fill(enemyTypes[1])
    ],

    // Level 3: More tough enemies, slight increase in speed
    [
        ...Array(10).fill(enemyTypes[0]),
        ...Array(5).fill(enemyTypes[1]),
        ...Array(5).fill(enemyTypes[2])
    ],
]



const Page = () => {

    const { data: session, status } = useSession()

    const [user, setUser] = useState<String | null>(null)

    useEffect(() => {
        if (session && session.user) {
            const user = session.user as { username: string }
            setUser(user.username)
        }
    }, [session])

    const [mainMenu, setMainMenu] = useState(true)

    // General state for user stats, towers, and enemies
    const [isGameRunning, setGameRunning] = useState(false)
    const lastUpdateRef = useRef<number>(0)
    const animationFrameRef = useRef<number | null>(null)
    const spawnTimerRef = useRef<number>(0)
    const spawnInterval = 0.42
    const enemyTotal = useRef(0)
    const enemyOnScreen = useRef(1)
    const enemySpawnIterator = useRef(0)

    const [projectiles, setProjectiles] = useState<Projectile[]>([])

    const [alertShown, setAlertShown] = useState({ enabled: false, type: '', message: '' })

    const [screen, setScreen] = useState({ width: 1024, height: 768 })

    const [currentLevel, setCurrentLevel] = useState(0)
    
    const [allMaps, setAllMaps] = useState([map1, map2, map3])
    const [selectedMap, setSelectedMap] = useState<Map>(map1)

    const [towerPaneOpen, setTowerPaneOpen] = useState(false)

    const [playerStats, setPlayerStats] = useState<PlayerStats>({ lives: 100, money: 300 })
    const [holdingTower, setHoldingTower] = useState({enabled: false, isCollided: false, tower: { name: '', cost: 0, range: 0, damage: 0, attackSpeed: 0, pos: { x: 0, y: 0} }})
    const [towers, setTowers] = useState<Tower[]>([
        {
            name: 'oldMan',
            cost: 750,
            range: 55,
            damage: 55,
            attackSpeed: 3,
            lastAttackTime: 0,
            radius: 0,
            pos: {
                x: 0,
                y: 0
            }
        },
        {
            name: 'angel',
            cost: 250,
            range: 100,
            damage: 5,
            attackSpeed: 0.5,
            lastAttackTime: 0,
            radius: 0,
            pos: {
                x: 0,
                y: 0
            }
        },
        {
            name: 'luis',
            cost: 1000,
            range: 300,
            damage: 1,
            attackSpeed: 1,
            lastAttackTime: 0,
            effect: {
                type: 'slow',
                amount: 0.7
            },
            radius: 0,
            pos: {
                x: 0,
                y: 0
            }
        },
        {
            name: 'joel',
            cost: 600,
            range: 75,
            damage: 25,
            attackSpeed: 1,
            lastAttackTime: 0,
            radius: 0,
            pos: {
                x: 0,
                y: 0
            }
        },
        {
            name: 'chan',
            cost: 1000,
            range: 250,
            damage: 50,
            attackSpeed: 5,
            lastAttackTime: 0,
            radius: 0,
            pos: {
                x: 0,
                y: 0
            }
        },
        {
            name: 'alex',
            cost: 150,
            range: 150,
            damage: 5,
            attackSpeed: 1,
            lastAttackTime: 0,
            radius: 0,
            pos: {
                x: 0,
                y: 0
            }
        },
    ])
    const [enemies, setEnemies] = useState<Enemy[]>([])

    const [placedTowers, setPlacedTowers] = useState<Tower[]>([])

    const [selectedTower, setSelectedTower] = useState<Tower | null>(null)

    // Reference for dragging towers
    const [boardMousePos, setBoardMousePos] = useState({ x: 0, y: 0 })

    const [ratio, setRatio] = useState(1)

    const mainBoard = useRef<HTMLDivElement | null>(null)


    // for fetching tower data from DB (debug)
    useEffect(() => {
        const fetchTowers = async () => {
            const response = await fetch(`/api/tower-defense`)
            const res = await response.json()
            setTowers(res[0].towers)
        }
        fetchTowers()
    }, [])




    // establishing state for screen dimensions
    useEffect(() => {
        if (mainBoard.current) {
            const container = mainBoard.current.getBoundingClientRect()
            setScreen({ width: container.width, height: container.height })
            setRatio(container.width / 1024)
        }
    }, [mainBoard])

    // LERP function in case I need it for something 
    // const lerp = (start: number, end: number, amount: number) => {
    //     return start + (end - start) * amount
    // }

    // Normalized movement so everything moves at a constant speed wherever I need it to go. Don't have to worry about directions
    const normalizedMovement = (start: { x: number, y: number }, end: { x: number, y: number }, speed: number) => {
        const vecX = end.x - start.x
        const vecY = end.y - start.y

        const dist = Math.sqrt(vecX * vecX + vecY * vecY)

        if (dist < speed) {
            return end
        }

        const dirX = vecX / dist
        const dirY = vecY / dist

        return {
            x: start.x + dirX * speed,
            y: start.y + dirY * speed
        }
    }




    // Function to convert percentages to actual pixel positions stolen from GPT because lazy
    const convertPercentToPixel = (percentPoint: { x: number, y: number }, canvasWidth: number, canvasHeight: number) => {
        return {
            x: percentPoint.x * canvasWidth,
            y: percentPoint.y * canvasHeight
        }
    }

    const convertIntToColor = (hp: number) => {
        const percent = (hp / 100) * 300
        return `hsl(${percent} 50% 50%)`
    }




    const selectMap = (map: Map) => {
        setSelectedMap(map)
        setMainMenu(false)
    }




    // for targeting and attacking enemies
    const targetAndAttackEnemy = (deltaTime: number) => {
        setPlacedTowers((prevTowers) => {
            return prevTowers.map((tower) => {
                const t = {
                    pos: tower.pos,
                    radius: (tower.range * ratio),
                }
    
                // Check if enough time has passed based on the tower's attackSpeed
                if (tower.lastAttackTime === undefined) {
                    tower.lastAttackTime = 0
                }
                
                tower.lastAttackTime += deltaTime
    
                // Only attack if enough time has passed since the last attack
                if (tower.lastAttackTime >= tower.attackSpeed) {
                    let damageApplied = false
    
                    setEnemies((prevEnemies) => {
                        return prevEnemies
                            .map((enemy) => {
                                if (damageApplied) {
                                    return enemy
                                }
    
                                const e = {
                                    pos: enemy.pos,
                                    radius: enemy.radius,
                                }
    
                                // Check for collision
                                if (isColliding(e, t)) {
                                    const newHp = enemy.hp - tower.damage
                                    if (newHp <= 0) {
                                        enemyTotal.current -= 1
                                        enemyOnScreen.current -= 1
                                        setPlayerStats((prev) => ({
                                            ...prev,
                                            money: prev.money + enemy.money,
                                        }))
                                    }

                                    // quick and dirty way to have towers that attack multiple targets at once
                                    if (tower.name === 'luis' || tower.name === 'chan' || tower.name === 'oldMan') {
                                        return {
                                            ...enemy,
                                            hp: newHp,
                                        }
                                    }
    
                                    // For other towers, only apply damage to the first colliding enemy
                                    if (!damageApplied) {
                                        damageApplied = true
                                        return {
                                            ...enemy,
                                            hp: newHp,
                                        }
                                    }
                                }
    
                                return enemy
                            })
                            .filter((enemy) => enemy.hp > 0)
                    })
    
                    // Reset the last attack time after attacking
                    tower.lastAttackTime = 0
                }
    
                return tower
            })
        })
    }

    // const targetAndAttackEnemy = (deltaTime: number) => {
    //     setPlacedTowers((prevTowers) => {
    //         return prevTowers.map((tower) => {
    //             const t = {
    //                 pos: tower.pos,
    //                 radius: (tower.range * ratio),
    //             }
    
    //             if (tower.lastAttackTime === undefined) {
    //                 tower.lastAttackTime = 0
    //             }
    
    //             tower.lastAttackTime += deltaTime
    
    //             if (tower.lastAttackTime >= tower.attackSpeed) {
    //                 setEnemies((prevEnemies) => {
    //                     const targetEnemy = prevEnemies.find((enemy) => {
    //                         const e = {
    //                             pos: enemy.pos,
    //                             radius: enemy.radius,
    //                         }
    //                         return isColliding(e, t)
    //                     })
    
    //                     if (targetEnemy) {
    //                         // Create a projectile aimed at the target enemy
    //                         setProjectiles((prevProjectiles) => [
    //                             ...prevProjectiles,
    //                             {
    //                                 pos: { 
    //                                     x: tower.pos.x + (32 * ratio) - 12.5,
    //                                     y: tower.pos.y + (32 * ratio) - 12.5
    //                                 },
    //                                 targetPos: { 
    //                                     x: targetEnemy.pos.x + (32 * ratio) - 12.5,
    //                                     y: targetEnemy.pos.y + (32 * ratio) - 12.5
    //                                 },
    //                                 speed: 400,
    //                                 damage: 1,
    //                                 collided: false
    //                             },
    //                         ])
    
    //                         // Reset the last attack time after firing
    //                         tower.lastAttackTime = 0
    //                     }
    
    //                     return prevEnemies
    //                 })
    //             }
    
    //             return tower
    //         })
    //     })
    // }
    
    // Function to update projectiles and check for collisions with enemies
    // const updateProjectiles = (deltaTime: number) => {
    //     setProjectiles((prevProjectiles) => {
    //         return prevProjectiles.map((projectile) => {
    //             const direction = {
    //                 x: projectile.targetPos.x - projectile.pos.x,
    //                 y: projectile.targetPos.y - projectile.pos.y,
    //             }
    //             const magnitude = Math.sqrt(direction.x ** 2 + direction.y ** 2)
    //             const normalizedDirection = {
    //                 x: direction.x / magnitude,
    //                 y: direction.y / magnitude,
    //             }
    
    //             projectile.pos.x += normalizedDirection.x * projectile.speed * deltaTime
    //             projectile.pos.y += normalizedDirection.y * projectile.speed * deltaTime

    //             let collided = false
    //             setEnemies((prevEnemies) => {
    //                 return prevEnemies.map((enemy) => {
    //                     const e = {
    //                         pos: enemy.pos,
    //                         radius: enemy.radius,
    //                     }
    //                     const p = {
    //                         pos: projectile.pos,
    //                         radius: 12.5,
    //                     }
    
    //                     if (isColliding(e, p)) {
    //                         const newHp = enemy.hp - 1
    //                         if (newHp <= 0) {
    //                             enemyTotal.current -= 0.5
    //                             enemyOnScreen.current -= 0.5
    //                             setPlayerStats((prev) => ({
    //                                 ...prev,
    //                                 money: prev.money + enemy.money,
    //                             }))
    //                         }
    //                         projectile.collided = true;
    //                         collided = true
    //                         return {
    //                             ...enemy,
    //                             hp: newHp,
    //                         }
    //                     }
    //                     return enemy
    //                 }).filter((enemy) => enemy.hp > 0)
    //             })

    //             // Remove projectiles that have reached their target
    //             if (projectile.collided || magnitude < 10) {
    //                 return null
    //             }
    
    //             return projectile
    //         }).filter((proj): proj is Projectile => proj !== null)
    
    //     })
    // }




    // to grab mouse position INSIDE board container
    const grabMousePos: MouseEventHandler<HTMLDivElement> | TouchEventHandler<HTMLDivElement> = (e: any) => {
        const boardRect = e.currentTarget.getBoundingClientRect()

        let x, y

        if ('touches' in e) {
            x = e.touches[0].clientX - boardRect.left
            y = e.touches[0].clientY - boardRect.top
        } else {
            x = e.clientX - boardRect.left
            y = e.clientY - boardRect.top
        }

        setBoardMousePos({ x, y })

        if (holdingTower.enabled) {
            let collided = false
            const colliders = document.querySelectorAll('.collider')
            const tower = {
                pos: {
                    x: x,
                    y: y
                },
                radius: 32 * ratio
            }
            colliders.forEach(collider => {
                const c = collider.getBoundingClientRect()
                const col = {
                    pos: {
                        x: c.x - boardRect.left + (32 * ratio),
                        y: c.y - boardRect.top + (32 * ratio)
                    },
                    radius: (c.width / 2)
                }
                const isCollided = isColliding(col, tower)
                if (isCollided) {
                    collided = true
                }
            })
            placedTowers.forEach(t => {
                const c = t.pos
                const col = {
                    pos: {
                        x: c.x + (32 * ratio),
                        y: c.y + (32 * ratio)
                    },
                    radius: ((50 * ratio) / 2)
                }
                const isCollided = isColliding(col, tower)
                if (isCollided) {
                    collided = true
                }
            })
            setHoldingTower(prev => ({
                ...prev,
                isCollided: collided
            }))
        }
    }






    // for grabbing a tower to place/purchase
    const grabTower = (tower: Tower) => {
        setHoldingTower({enabled: true, isCollided: false, tower: tower})
    }

    // for setting a tower at the point you clicked
    const setTower = (name: string, pos: { x: number, y: number }) => {
        const tower = towers.find(tower => tower.name === name)
        if (tower && !holdingTower.isCollided) {
            tower.pos = pos
            setPlacedTowers(prev => [
                ...prev,
                { ...tower }
            ])
            setPlayerStats((prev) => ({
                ...prev,
                money: prev.money - tower.cost
            }))
            setHoldingTower({enabled: false, isCollided: false, tower: { name: '', cost: 0, range: 0, damage: 0, attackSpeed: 0, pos: { x: 0, y: 0} }})
        } else {
            setHoldingTower({enabled: false, isCollided: false, tower: { name: '', cost: 0, range: 0, damage: 0, attackSpeed: 0, pos: { x: 0, y: 0} }})
        }

    }

    const selectTower = (tower: Tower) => {
        setSelectedTower(tower)
    }

    const deleteSelectedTower = () => {
        if (selectedTower) {
            const temp = placedTowers.filter(tower => tower.pos != selectedTower.pos)

            setPlayerStats((prev) => ({
                ...prev,
                money: prev.money + (selectedTower.cost / 2)
            }))

            setPlacedTowers(temp)
            setSelectedTower(null)
        }
    }




    // Circular collision check, makes more sense for this application. Stolen/modified from GIPPITY
    function isColliding(obj1: { pos: {x: number, y: number, }, radius: number}, obj2: { pos: {x: number, y: number, }, radius: number}): boolean {

        // Calculate the distance between the centers
        const dx = obj2.pos.x - obj1.pos.x
        const dy = obj2.pos.y - obj1.pos.y
        const distance = Math.sqrt(dx * dx + dy * dy)

        // Check if the distance is less than or equal to the sum of the radii
        return distance <= (obj1.radius + obj2.radius)
    }

    // spawns enemies if need to spawn enemies
    const spawnEnemies = (deltaTime: number) => {
        
        spawnTimerRef.current += deltaTime
        let spawnMultiplier = waves[currentLevel][enemySpawnIterator.current].spd

        // if (waves[currentLevel][enemyOnScreen.current - 1]) {
        //     spawnMultiplier = waves[currentLevel][enemySpawnIterator.current].spd
        // } else {
        //     spawnMultiplier = waves[currentLevel][enemySpawnIterator.current].spd
        // }

        let pos = {x: 0, y: 0}

        if (selectedMap) {
            let firstPoint = {
                x: selectedMap.pathPoints[0].x * ratio,
                y: selectedMap.pathPoints[0].y * ratio
            }

            // pos = convertPercentToPixel(firstPoint, screen.width, screen.height)
            pos = firstPoint
        }

        if (spawnTimerRef.current >= (spawnInterval / spawnMultiplier) && enemyOnScreen.current < enemyTotal.current && enemySpawnIterator.current != waves[currentLevel].length) {
            spawnTimerRef.current = 0
      
            setEnemies((prevEnemies) => {
                const currentEnemy = waves[currentLevel][enemySpawnIterator.current]
                return [
                    ...prevEnemies,
                    { idx: 0, hp: currentEnemy.hp, spd: currentEnemy.spd, money: currentEnemy.money, radius: 25 * ratio, pos: pos, color: currentEnemy.color },
                ]   
            })
      
            enemySpawnIterator.current += 1
            enemyOnScreen.current += 1
        }
    }

    // moves all spawned enemies
    const moveEnemies = (deltaTime: number) => {
        setEnemies((prev) => {
            const updatedEnemies = prev.map((enemy) => {
                
                let currentIdx = enemy.idx || 0
                let speed = enemy.spd

                const pixelPoint = {
                    x: selectedMap.pathPoints[currentIdx].x * ratio,
                    y: selectedMap.pathPoints[currentIdx].y * ratio
                }

                // const currentPoint = convertPercentToPixel(pixelPoint, screen.width, screen.height)
            
                const isAtCurrentPoint = enemy.pos.x === pixelPoint.x && enemy.pos.y === pixelPoint.y

                const newIdx = isAtCurrentPoint ? currentIdx + 1 : currentIdx

                const newPixelPoint = {
                    x: selectedMap.pathPoints[newIdx].x * ratio,
                    y: selectedMap.pathPoints[newIdx].y * ratio
                }

                // const nextPoint = convertPercentToPixel(newPixelPoint, screen.width, screen.height)


                placedTowers.forEach((tower) => {
                    if (isColliding({pos: enemy.pos, radius: enemy.radius}, {pos: tower.pos, radius: (tower.range * ratio)}) && tower.name === 'luis') {
                        if (tower.effect) {
                            speed = enemy.spd * tower.effect.amount
                        }
                    }
                })

            
                const newPos = normalizedMovement(
                    enemy.pos,
                    newPixelPoint,
                    deltaTime * ((150 * ratio) * speed)
                )
            
                // Check if enemy reaches the last path point
                if (newPos.x === newPixelPoint.x && newPos.y === newPixelPoint.y && newIdx === selectedMap.pathPoints.length - 1) {
                    enemyTotal.current -= 1
                    enemyOnScreen.current -= 1
                    
                    setPlayerStats((prev) => {
                        if ((prev.lives - enemy.hp) <= 0) {
                            stopGame('gameOver', 'Game over!')
                        }
                        return {
                        ...prev,
                        lives: prev.lives - enemy.hp,
                    }})
                    return null
                }
            
                return {
                    ...enemy,
                    pos: newPos,
                    idx: newIdx
                }
            }).filter((enemy): enemy is Enemy => enemy !== null)
        
            return updatedEnemies
        })
    }

    // main loop that calls all updates
    const updateGame = (deltaTime: number) => {
        // checks if enemyTotal is 0, in which case the game loop stops
        if (enemyTotal.current <= 0) {
            stopGame('win', 'Wave completed!')
        }

        // checks player lives and stops game if 0
        if (playerStats.lives <= 0) {
            stopGame('gameOver', 'Game over!')
            // do other thing (show game over screen or something)
        }

        moveEnemies(deltaTime)
        spawnEnemies(deltaTime)
        targetAndAttackEnemy(deltaTime)
        // updateProjectiles(deltaTime)
    }

    // main game loop that tracks deltaTime and calls updateGame
    const main = (currentTime: number) => {
        if (!lastUpdateRef.current) {
            lastUpdateRef.current = currentTime
        }
        const deltaTime = (currentTime - lastUpdateRef.current) / 1000
        lastUpdateRef.current = currentTime
    
        updateGame(deltaTime)
    
        if (isGameRunning) {
            animationFrameRef.current = requestAnimationFrame(main)
        }
    }

    // changes conditional to allow game loop to begin
    const startGame = () => {

        enemySpawnIterator.current = 0

        enemyTotal.current = waves[currentLevel].length - 1
        enemyOnScreen.current = 0
        if (!isGameRunning) {
            setGameRunning(true)
            setAlertShown({ enabled: false, type: '', message: '' })
        }
    }

    // changes conditional to stop game loop/resets values
    const stopGame = (type: string, message: string) => {
        if (animationFrameRef.current) {
            cancelAnimationFrame(animationFrameRef.current)
        }
        setGameRunning(false)
        if (currentLevel == waves.length - 1) {
            setAlertShown({ enabled: true, type: 'gameComplete', message: 'You completed all 50 levels!' })
        } else if (currentLevel < waves.length - 1) {
            setAlertShown({ enabled: true, type: type, message: message })
            if (type === 'win') {
                setCurrentLevel(currentLevel + 1)
                setTimeout(() => {
                    setAlertShown({ enabled: false, type: type, message: message })
                }, 2000)
            }
        }
    }

    const resetGame = () => {
        setEnemies([])
        setCurrentLevel(0)
        setPlayerStats({ lives: 100, money: 300 })
        setPlacedTowers([])
        setAlertShown({ enabled: false, type: 'gameOver', message: 'Game over!' })
        setMainMenu(true)
    }

    // useEffect for setting main game loop to run on startGame()
    useEffect(() => {
        if (isGameRunning) {
            animationFrameRef.current = requestAnimationFrame(main);
        }

        return () => {
            if (animationFrameRef.current) {
                cancelAnimationFrame(animationFrameRef.current)
            }
        }
    }, [isGameRunning])




    // for changing tower values (debug)
    const changeTowerValues = (e: React.ChangeEvent<HTMLInputElement>, towerName: string, propertyName: keyof Tower) => {
        const updatedValue = propertyName === 'cost' ? parseInt(e.target.value) : e.target.value

        const updatedTowers = towers.map((t) =>
          t.name === towerName ? { ...t, [propertyName]: updatedValue } : t
        )
      
        setTowers(updatedTowers)
    }

    const pushTowerValuesToDB = async () => {
        const response = await fetch(`/api/tower-defense`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(towers)
        })
    }

    return (
        <div className="flex-1 flex flex-col gap-3 justify-center sm:pt-16 items-center chatBg">
            <div ref={mainBoard} className="relative rounded sm:rounded-none bg-neutral-900 sm:border-x-none max-w-[1024px] max-h-[768px] overflow-hidden flex flex-col justify-evenly items-center"  style={{ aspectRatio: '4/3', width: '100%', height: 'auto' }}>
            {mainMenu ? (
                <div className="w-full h-full absolute top-0 left-0 flex flex-col justify-evenly items-center">
                    <h1 className="text-neutral-200 font-bold text-5xl sm:text-2xl text-center">The Cul-De-Sac Defense</h1>
                    <h1 className="text-neutral-200 font-bold text-2xl sm:text-sm text-center">Choose A Level:</h1>
                    <div className="w-full h-1/3 sm:h-1/2 flex items-center justify-center gap-1 px-1">
                        {allMaps.map((map, index) => {
                            return (
                                <div key={index} onClick={() => selectMap(map)} id={map.name} className="w-1/3 aspect-[4/3] cursor-pointer rounded"></div>
                            )
                        })}
                    </div>
                </div>
            ) : (
                <div id={selectedMap?.name} onMouseMove={grabMousePos as MouseEventHandler<HTMLDivElement>} onTouchMove={grabMousePos as TouchEventHandler<HTMLDivElement>} className="w-full h-full">

                {!isGameRunning && alertShown.enabled ? (
                    <div className="w-full h-4/5 absolute top-0 left-0 flex flex-col gap-3 items-center justify-center mt-12 sm:mt-8 alertPane alertActive">
                        <h1 className="bg-green-700 px-3 py-2 font-bold text-neutral-200 text-2xl sm:text-lg rounded border border-neutral-700 shadow-lg">{alertShown.message}</h1>
                        {alertShown.type === 'gameOver' ? (
                            <button className="cursor-pointer text-neutral-200 hover:underline" onClick={resetGame}>New Game</button>
                        ) : alertShown.type === 'gameComplete' ? (
                            <button className="cursor-pointer text-neutral-200 hover:underline" onClick={resetGame}>Main Menu</button>
                        ) : (
                            <></>
                        )}
                    </div>
                ) : (
                    <div className="w-full h-4/5 absolute top-0 left-0 flex flex-col gap-3 items-center justify-center mt-12 sm:mt-8 alertPane alertInactive">
                        <h1 className="bg-green-700 px-3 py-2 font-bold text-neutral-200 text-2xl sm:text-lg rounded border border-neutral-700 shadow-lg">{alertShown.message}</h1>
                        {alertShown.type === 'gameOver' ? (
                            <button className="cursor-pointer text-neutral-200 hover:underline">New Game</button>
                        ) : (
                            <></>
                        )}
                    </div>
                )}

                <div className="absolute top-0 left-0 w-auto flex flex-col items-start justify-center stat-pane bg-black/70 rounded-br-lg">
                    <h1 className="text-neutral-200 font-bold text-sm sm:text-xs px-3 py-2 sm:px-2 sm:py-[2px] drop-shadow">Wave: {currentLevel + 1}</h1>
                    <h1 className="text-neutral-200 font-bold text-sm sm:text-xs px-3 py-2 sm:px-2 sm:py-[2px] drop-shadow">${playerStats.money}</h1>
                    <h1 className="text-neutral-200 font-bold text-sm sm:text-xs px-3 py-2 sm:px-2 sm:py-[2px] drop-shadow">❤️ {playerStats.lives}</h1>
                </div>

                {!isGameRunning ? (
                    <button className="absolute top-1 sm:top-1 right-3 sm:right-1 text-neutral-200 border-2 border-neutral-700 text-xs font-bold rounded-full bg-green-600 hover:bg-green-700 py-2 px-4 sm:px-2 sm:py-1 aspect-square start-btn" onClick={startGame}>Go</button>
                ) : (
                    <button className="absolute top-1 sm:top-1 right-3 sm:right-1 text-neutral-200 border-2 border-neutral-700 text-xs font-bold rounded-full bg-green-700 py-2 px-4 sm:px-2 sm:py-1 opacity-50 cursor-not-allowed aspect-square start-btn">Go</button>
                )}

                {!alertShown.enabled ? (
                    <div>
                        {selectedMap ? selectedMap.collisions.map((col, index) => {
                            const container = mainBoard.current?.getBoundingClientRect()
                            let totalCols = 16
                            if (col == 1 && container) {
                                return (
                                    <div key={index} className="collider bg-red-700/00 absolute" style={{ top: `${Math.floor(index / totalCols) * ((container.width - 2) / 16)}px`, left: `${(index % totalCols) * ((container.width - 2) / 16)}px`, width: `${container.width / 16}px`, aspectRatio: '1/1'}}></div>
                                )
                            }
                        }) : (<></>)}
                    </div>
                ) : (
                    <></>
                )}


                <div id="enemies">
                    {enemies.map((enemy, index) => {
                        const container = mainBoard.current?.getBoundingClientRect()
                        if (container) {
                            return (
                                <div key={index} className="flex items-center justify-center rounded-full absolute border-2 border-neutral-800 overflow-hidden" style={{ backgroundColor: `${enemy.color}`, top: `${enemy.pos.y}px`, left: `${enemy.pos.x}px`, boxShadow: `0px 0px 5px 2px rgba(0,0,0,0.15)`, width: `${(container.height) * 0.083}px`, aspectRatio: '1/1' }}><h1 className="font-bold text-neutral-200 sm:text-xs z-10">{enemy.hp}</h1>
                                </div>
                            )
                        }
                    })}
                </div>

                <div id="projectiles">
                    {projectiles.map((proj, index) => {
                        const container = mainBoard.current?.getBoundingClientRect()
                        if (container) {
                            return (
                                <div key={index} className="flex items-center justify-center rounded-full absolute border-2 border-neutral-800 overflow-hidden" style={{ backgroundColor: `black`, top: `${proj.pos.y}px`, left: `${proj.pos.x}px`, boxShadow: `0px 0px 5px 2px rgba(0,0,0,0.15)`, width: `${(container.height) * 0.033}px`, aspectRatio: '1/1' }}>
                                </div>
                            )
                        }
                    })}
                </div>

                {holdingTower.enabled ? (
                    <div onClick={() => setTower(holdingTower.tower.name, {x: boardMousePos.x - (32 * ratio), y: boardMousePos.y - (32 * ratio)} )} onTouchEnd={() => setTower(holdingTower.tower.name, {x: boardMousePos.x - (32 * ratio), y: boardMousePos.y - (32 * ratio)} )} style={{ top: `${boardMousePos.y - (32 * ratio)}px`, left: `${boardMousePos.x - (32 * ratio)}px`, width: `${(screen.height) * 0.083}px`, aspectRatio: '1/1', boxShadow: holdingTower.isCollided ? `0px 0px 0px ${holdingTower.tower.range * ratio}px rgba(255,0,0,0.50)` : `0px 0px 0px ${holdingTower.tower.range * ratio}px rgba(128,128,128,0.25)` }} className={`${holdingTower.tower.name} held-tower flex items-center justify-center cursor-pointer rounded-full bg-green-700 border-2 border-neutral-700 absolute`}><h1 className="font-bold text-neutral-200"></h1></div>
                ) : (<></>)}

                <div id="placed-towers">
                    {placedTowers.map((tower, index) => {
                        return (
                            <div key={index} onClick={(e) => {selectTower(tower)}} style={{ top: `${tower.pos.y}px`, left: `${tower.pos.x}px`, width: `${(screen.height) * 0.083}px`, aspectRatio: '1/1', boxShadow: selectedTower == tower ? `0px 0px 0px ${selectedTower.range * ratio}px rgba(128,128,128,0.25)` : `0px 0px 3px rgba(0,0,0,0.2)`, border: selectedTower == tower ? `solid 2px #22c55e` : `solid 2px #404040` }} className={`${tower.name} flex items-center justify-center  shadow-sm cursor-pointer rounded-full absolute`}><h1 className="font-bold text-neutral-200"></h1></div>
                        )
                    })}
                </div>

                {towerPaneOpen ? (
                    <div id="tower-pane" className="absolute bottom-0 left-0 border-t border-neutral-800 w-full h-1/5 bg-neutral-600 flex items-center justify-between sm:p-0 ">
                        <button className='absolute -top-8 left-1 rounded bg-green-600 border-2 border-neutral-700 text-xs text-white px-2 py-1' onClick={() => setTowerPaneOpen(false)}>Close</button>
                        <div className="flex items-center sm:p-0 w-full h-full justify-between sm:gap-0 sm:h-full sm:divide-x sm:divide-black">
                            {towers.map((tower, index) => {
                                if (tower.cost <= playerStats.money) {
                                    return (
                                        <div key={index} onClick={() => {grabTower(tower); setTowerPaneOpen(false)}} onTouchStart={() => {grabTower(tower); setTowerPaneOpen(false)}}  style={{ boxShadow: `inset 0px 0px 7px 2px rgba(0,0,0,0.1)` }} className={`${tower.name} tower-tab relative w-1/6 h-full flex items-center cursor-pointer justify-center`}>
                                            <div className={`flex flex-col w-full h-full bg-neutral-800/25 justify-evenly absolute top-0 left-0 px-1 tower-stats`}>
                                                <h1 className="text-neutral-200 font-bold sm:text-[10px]">${tower.cost}</h1>
                                                <h1 className="text-neutral-200 font-bold sm:text-[10px]">{tower.damage} <span className="text-neutral-300 font-medium">dmg</span></h1>
                                                <h1 className="text-neutral-200 font-bold sm:text-[10px]">{tower.range} <span className="text-neutral-300 font-medium">range</span></h1>
                                                <h1 className="text-neutral-200 font-bold sm:text-[10px]">{(1 / tower.attackSpeed).toPrecision(2)} <span className="text-neutral-300 font-medium">spd</span></h1>
                                            </div>
                                        </div>
                                    )
                                } else {
                                    return (
                                        <div key={index} style={{ boxShadow: `inset 0px 0px 7px 2px rgba(0,0,0,0.1)` }} className={`${tower.name} tower-tab relative w-1/6 h-full flex items-center cursor-not-allowed justify-center opacity-25`}>
                                            <div className={`flex flex-col w-full h-full bg-neutral-800/25 justify-evenly absolute top-0 left-0 px-1 tower-stats`}>
                                                <h1 className="text-neutral-200 font-bold sm:text-[10px]">${tower.cost}</h1>
                                                <h1 className="text-neutral-200 font-bold sm:text-[10px]">{tower.damage} <span className="text-neutral-300 font-medium">dmg</span></h1>
                                                <h1 className="text-neutral-200 font-bold sm:text-[10px]">{tower.range} <span className="text-neutral-300 font-medium">range</span></h1>
                                                <h1 className="text-neutral-200 font-bold sm:text-[10px]">{(1 / tower.attackSpeed).toPrecision(2)} <span className="text-neutral-300 font-medium">spd</span></h1>
                                            </div>
                                        </div>
                                    )
                                }
                            })}
                        </div>
                    </div>
                ) : (
                    <button className='absolute bottom-1 left-1 rounded bg-green-600 border-2 border-neutral-700 text-xs text-white px-2 py-1' onClick={() => setTowerPaneOpen(true)}>Towers</button>
                )}

                {selectedTower ? (
                    <div id="tower-pane" className="absolute bottom-0 left-0  w-full h-1/5 bg-black/50 backdrop-blur-sm flex items-center justify-center sm:p-0 ">
                        <button onClick={() => deleteSelectedTower()} className="bg-blue-700 active:bg-blue-800 font-bold text-neutral-200 rounded text-4xl px-4 py-2 sm:text-xl">Sell Tower</button>
                        <button onClick={() => setSelectedTower(null)} className="text-neutral-200 text-2xl underline sm:text-sm absolute right-3">close</button>
                    </div>
                ) : (
                    <></>
                )}
            </div>
            )}
            </div>
            {session && session.user != null ? (
                <div className="flex w-full max-w-[1024px] sm:mb-3 gap-3 sm:flex-wrap sm:justify-evenly h-1/5 sm:h-2/5 overflow-y-scroll">
                    <button className="bg-blue-700 p-2 py-1 text-neutral-200 font-bold rounded-sm" onClick={pushTowerValuesToDB}>Submit</button>
                    <div className="w-full flex justify-center sm:flex-wrap gap-3">
                        {towers.map((tower, index) => {
                            return (
                                <div key={index} className="w-1/6 sm:w-[45%] flex flex-col gap-1">
                                    <h1 className="font-bold text-sm text-neutral-200 text-center">{tower.name}</h1>
                                    <label className="text-neutral-500 text-xs" htmlFor="cost">Cost:</label>
                                    <input className="w-full bg-neutral-600 rounded-sm text-neutral-200" type="number" name="cost" id="" placeholder={"$" + tower.cost.toString()} value={tower.cost.toString()} onChange={(e) => changeTowerValues(e, tower.name, 'cost')}/>
                                    <label className="text-neutral-500 text-xs" htmlFor="dmg">Damage:</label>
                                    <input className="w-full bg-neutral-600 rounded-sm text-neutral-200" type="number" name="dmg" id="" placeholder={"Dmg: " + tower.damage.toString()} value={tower.damage.toString()} onChange={(e) => changeTowerValues(e, tower.name, 'damage')} />
                                    <label className="text-neutral-500 text-xs" htmlFor="range">Range:</label>
                                    <input className="w-full bg-neutral-600 rounded-sm text-neutral-200" type="number" name="range" id="" placeholder={"Range: " + tower.range.toString()} value={tower.range.toString()} onChange={(e) => changeTowerValues(e, tower.name, 'range')} />
                                    <label className="text-neutral-500 text-xs" htmlFor="Speed">Speed:</label>
                                    <input className="w-full bg-neutral-600 rounded-sm text-neutral-200" type="number" name="speed" id="" placeholder={"Spd: " + tower.attackSpeed.toString()} value={tower.attackSpeed.toString()} onChange={(e) => changeTowerValues(e, tower.name, 'attackSpeed')} />
                                </div>
                            )
                        })}
                    </div>
                </div>
            ) : (
                <></>
            )}
        </div>
    )
}

export default Page